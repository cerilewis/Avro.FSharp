# Avro.FSharp

FSharp implementation of Apache Avro

## Overview

The library generates an Avro schema by an F# type as well as provides reader and writer classes.

## Schema

Schema is generated by `Schema.generate: CustomRule list -> Type -> Result<Schema,SchemaError>` function:

```fsharp
let schema = Avro.FSharp.Schema.generate [] typeof<MyType>
```

### Primitive types

F# types `string`, `bool`, `int`, `int64`, `float32`, `float`, `byte array` are mapped to corresponding Avro's primitives.

Examples:
* `generate [] typeof<string>` generates: `{"type": "string"}`
* `generate [] typeof<bool>` generates: `{"type": "boolean"}`
* `generate [] typeof<int>` generates: `{"type": "int"}`
* `generate [] typeof<int64>` generates: `{"type": "long"}`
* `generate [] typeof<float32>` generates: `{"type": "float"}`
* `generate [] typeof<float>` generates: `{"type": "double"}`
* `generate [] typeof<byte array>` generates: `{"type": "bytes"}`

### Maps

F# `IEnumerable<KeyValuePair<_,_>>` is mapped to Avro's `map`.

Examples:
* `generate [] typeof<Map<string,string>>` generates: `{"type": "map", "values": "string"}`
* `generate [] typeof<Dictionary<string, int>>` generates: `{"type": "map", "values": "int"}`

### Array

F# `IEnumerable<_>` is mapped to Avro's `array`.

Examples:
* `generate [] typeof<string list>` generates: `{"type": "array", "values": "string"}`
* `generate [] typeof<int array>` generates: `{"type": "array", "values": "int"}`
* `generate [] typeof<List<bool>>` generates: `{"type": "array", "values": "boolean"}`

### Enums

F# Enum is mapped to Avro's `enum`

Example:

```fsharp
type TestState =
    | Red = 3
    | Yellow = 2
    | Green = 1

generate [] typeof<TestState>
```
generated schema:
```json 
{"type": "enum", "name": "TestState", "symbols": ["Red", "Yellow", "Green"]}
```

### Records

F# Record is mapped to Avro's `record`

Example:

```fsharp
type SimpleRecord = {
    Id : int
    Name : string
    Version : int64}

generate [] typeof<SimpleRecord>
```
generated schema:
```json 
{
    "type": "record",
    "name": "SimpleRecord",
    "fields" : [
        {"name": "Id", "type": "int"},            
        {"name": "Name", "type": "string"},
        {"name": "Version", "type": "long"}
    ]                
}
```

Tuple is mapped to Avro's `record` with fields `Item1`, `Item2` and so on.

Example:

`generate [] typeof<int*string>>` generates
```json
{
    "type": "record",
    "name": "System.Tuple_Of_System_Int32_And_System_String",
    "fields" : [
        {"name": "Item1", "type": "int"},            
        {"name": "Item2", "type": "string"},
    ]                
}
```

Generic records are also allowed:
```fsharp
type GenericRecord<'T> = {
    Value : 'T
}

generateSchema typeof<GenericRecord<string>>
```
generated schema:
```json
{
    "type":"record",
    "name":"GenericRecord_Of_System_String",
    "fields":[{"name":"Value","type":"string"}]
}
```
### Unions

F# Discriminated Union is mapped to Avro's `union` of records, generated from the union's cases

Example:

```fsharp
type BinaryTree =
    | Leaf of value:string
    | Node of left: BinaryTree * right: BinaryTree

generate [] typeof<BinaryTree>
```
generated schema:
```json
{
    "type":[
        {
            "type":"record",
            "name":"Leaf",
            "fields":[
                {"name":"value","type":"string"}
            ]
        },
        {
            "type":"record",
            "name":"Node",
            "fields":[
                {"name":"left","type":["Leaf","Node"]},
                {"name":"right","type":["Leaf","Node"]}
            ]
        }
    ]
}
```

Option is mapped as `union` of `null` and the option's generic argument's type

Example:

`generate [] typeof<Option<float>>` generates `["null","double"]`

### Logical types
F# `decimal` is mapped to `{"type": "bytes", "logicalType": "decimal", "precision": 29, "scale": 14}`. Scale may be overrided by `ScaleAttribute`

## Annotations
Annotation Attributes allow to set additional schema's properties.
### DefaultValue
`type DefaultValueAttribute (defaultValue:string)` - default value for a record's field.
### Aliases
`type AliasesAttribute (aliases:string array)` - aliases for an enum, a record or a record's field.
### Scale
`type ScaleAttribute (scale:int)` - scale for decimal field.

## Names
Names of the enums and the records is constructed from namespace, module name and generic type arguments. Due to the fact that only `[A-Za-z0-9_]` symbols are allowed, some substitutions are performed.

Examples of record names:
* `Microsoft.FSharp.Core.FSharpResult_Of_System_Int64_And_System_String.Ok`
* `System.Tuple_Of_System_Int32_And_System_String`
* `Foo.Bar.GenericRecord_Of_Nullable_Of_System_String`

# Serde

For serializing use `FSharpWriter<'T>` which implements `Avro.Generic.DatumWriter<'T>`, for deserializing use `FSharpReader<'T>` which implements `Avro.Generic.DatumReader<'T>`. Here is basic example:

```fsharp
match Schema.generateWithReflector [] typeof<'T> with
| Ok (schema, reflector) -> 
    let schema = Schema.Parse(schema |> Schema.toString)
    let writer = FSharpWriter<'T>(schema, reflector)                
    use writerStream = new MemoryStream(256)
    writer.Write(data, BinaryEncoder(writerStream))

    use readerStream = new MemoryStream(writerStream.ToArray())
    let reader = FSharpReader<'T>(schema, schema, reflector)
    let deserializedData = reader.Read(Unchecked.defaultof<'T>, BinaryDecoder(readerStream))
    comparer "Deserialized data should be equal to original" data deserializedData
| Error err -> failwithf "Schema error %A" err 
```
## Deserialization issues
### Supported types for an array
Reading of an array will be successfull if corresponding type is:
* Dotnet array
* F# List
* Has constructor which accepts IEnumerable<_>

### Supported types for a map
Reading of a map will be successful if corresponding type is:
* F# Map<string,_>
* Dictionary<string,_>

# Custom Rules

It is possible to customize processing of a particular type. In that case `CustomRule` should be created.
```fsharp
type CustomRule = {
    TargetType: System.Type;
    Schema: string
    WriteCast: obj -> obj
    ReadCast: obj -> obj
}
```
There are several build in rules:
* `Guid` is mapped to byte array
* `Uri` is mapped to string
* `DateTime` is mapped to ISO 8601 string
* `DateTimeOffset` is mapped to ISO 8601 string
* `TimeSpan` is mapped to ISO 8601 string

Array with custom rules should be passed as first argument to `Schema.generate`.

# Examples
More examples of complex types and corresponging schemas is available in the [SchemaTests.fs](https://github.com/usix79/Avro.FSharp/blob/main/test/Avro.FSharp.Tests/SchemaTests.fs).

See [CustomRule.fs](https://github.com/usix79/Avro.FSharp/blob/main/src/Avro.FSharp/CustomRule.fs) for details of the implementation of the custom rules.

An implementation of Kafka producer and consumer, working with SchemaRegistry could be found [here](https://github.com/usix79/Avro.FSharp/tree/main/examples/KafkaSerde). (*The example is supposed you have an account in confluent.cloud. Change configuration code if you have on-premise installation.*)