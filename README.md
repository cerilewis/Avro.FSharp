# Avro.FSharp

FSharp implementation of Apache Avro

## Overview

The library generates an Avro schema by an F# type as well as serialize and deserialise an F# data in binary and json encodings.

## Schema

Schema is generated by `Schema.generate: CustomRule list -> Type -> Result<Schema,SchemaError>` function:

```fsharp
let schema =
    match Avro.FSharp.Schema.generate [] typeof<MyType> with
    | Ok schema -> schema
    | Error err -> failwithf "Schema Error: %A" err
```

Use following functions for converting a schema to string and vice versa:

```fsharp
let schema = Schema.ofString jsonSchemaString
printf "Schema: %s" (Schema.toString schema)
printf "Canonical schema: %s" (Schema.toCanonicalString schema)
```

### Primitive types

F# types `string`, `bool`, `int`, `int64`, `float32`, `float`, `byte array` are mapped to corresponding Avro's primitives.

Examples:
* `generate [] typeof<string>` generates: `{"type": "string"}`
* `generate [] typeof<bool>` generates: `{"type": "boolean"}`
* `generate [] typeof<int>` generates: `{"type": "int"}`
* `generate [] typeof<int64>` generates: `{"type": "long"}`
* `generate [] typeof<float32>` generates: `{"type": "float"}`
* `generate [] typeof<float>` generates: `{"type": "double"}`
* `generate [] typeof<byte array>` generates: `{"type": "bytes"}`

### Maps

F# `IEnumerable<KeyValuePair<_,_>>` is mapped to Avro's `map`.

Examples:
* `generate [] typeof<Map<string,string>>` generates: `{"type": "map", "values": "string"}`
* `generate [] typeof<Dictionary<string, int>>` generates: `{"type": "map", "values": "int"}`

### Array

F# `IEnumerable<_>` is mapped to Avro's `array`.

Examples:
* `generate [] typeof<string list>` generates: `{"type": "array", "values": "string"}`
* `generate [] typeof<int array>` generates: `{"type": "array", "values": "int"}`
* `generate [] typeof<List<bool>>` generates: `{"type": "array", "values": "boolean"}`

### Enums

F# Enum is mapped to Avro's `enum`

Example:

```fsharp
type TestState =
    | Red = 3
    | Yellow = 2
    | Green = 1

generate [] typeof<TestState>
```
generated schema:
```json
{"type": "enum", "name": "TestState", "symbols": ["Green", "Yellow", "Red"]}
```

### Records

F# Record is mapped to Avro's `record`

Example:

```fsharp
type SimpleRecord = {
    Id : int
    Name : string
    Version : int64}

generate [] typeof<SimpleRecord>
```
generated schema:
```json
{
    "type": "record",
    "name": "SimpleRecord",
    "fields" : [
        {"name": "Id", "type": "int"},
        {"name": "Name", "type": "string"},
        {"name": "Version", "type": "long"}
    ]
}
```

A tuple is mapped to Avro's `record` with fields `Item1`, `Item2` and so on.

Example:

`generate [] typeof<int*string>>` generates
```json
{
    "type": "record",
    "name": "System.Tuple_Of_System_Int32_And_System_String",
    "fields" : [
        {"name": "Item1", "type": "int"},
        {"name": "Item2", "type": "string"},
    ]
}
```

Generic records are also allowed:
```fsharp
type GenericRecord<'T> = {
    Value : 'T
}

generateSchema typeof<GenericRecord<string>>
```
generated schema:
```json
{
    "type":"record",
    "name":"GenericRecord_Of_System_String",
    "fields":[{"name":"Value","type":"string"}]
}
```
### Unions

F# Discriminated Union is mapped to Avro's `union` of records, generated from the union's cases

Example:

```fsharp
type BinaryTree =
    | Leaf of value:string
    | Node of left: BinaryTree * right: BinaryTree

generate [] typeof<BinaryTree>
```
generated schema:
```json
{
    "type":[
        {
            "type":"record",
            "name":"Leaf",
            "fields":[
                {"name":"value","type":"string"}
            ]
        },
        {
            "type":"record",
            "name":"Node",
            "fields":[
                {"name":"left","type":["Leaf","Node"]},
                {"name":"right","type":["Leaf","Node"]}
            ]
        }
    ]
}
```

Option is mapped as `union` of `null` and the option's generic argument's type

Example:

`generate [] typeof<Option<float>>` generates `["null","double"]`

### Logical types
F# `decimal` is mapped to `{"type": "bytes", "logicalType": "decimal", "precision": 29, "scale": 14}`. Scale may be overrided by `ScaleAttribute`

## Annotations
Annotation Attributes allow to set additional schema's properties.
### DefaultValue
`type DefaultValueAttribute (defaultValue:string)` - default value for a record's field.
### Aliases
`type AliasesAttribute (aliases:string array)` - aliases for an enum, a record or a record's field.
### Scale
`type ScaleAttribute (scale:int)` - scale for decimal field.

## Names
Names of the enums and the records is constructed from namespace, module name and generic type arguments. Due to the fact that only `[A-Za-z0-9_]` symbols are allowed, some substitutions are performed.

Examples of record names:
* `Microsoft.FSharp.Core.FSharpResult_Of_System_Int64_And_System_String.Ok`
* `System.Tuple_Of_System_Int32_And_System_String`
* `Foo.Bar.GenericRecord_Of_Nullable_Of_System_String`

# Serde

Implementation of serialization and deserialization is based on [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern). The library consist of three implementations of the pattern.

|Â Implementation | Director | Builder |
| -------------- | -------- | ------- |
| Instance | `type InstanceDirector(factory: IInstanceFactory)` - deconstructs an F# instance | `type InstanceBuilder(factory: IInstanceFactory)` - constructs an F# instance |
| Binary | `type BinaryDirector()` - read from binary encoding | `type BinaryBuilder(writer:BinaryWriter)` - write to binary encoding |
| Json | `type JsonDirector()`  - read from json encoding | `type JsonBuilder(writer:Utf8JsonWriter)`  - write to json encoding |

For seralization an F# instance, pair `InstanceDirector` with a builder (eg `BinaryBuilder`).
For deseralization an F# instance, pair a director (eg `BinaryDirector`) with `InstanceBuilder`.

Here is basic example:

```fsharp
let instance = createExampleInstance()

let factory = InstanceFactory(instance.GetType(), [])
let instanceDirector = InstanceDirector(factory)
use stream = new MemoryStream()
use writer = new BinaryWriter(stream, System.Text.Encoding.UTF8)
let binaryBuilder = BinaryBuilder(writer)
instanceDirector.Construct(instance, binaryBuilder)

let data = stream.ToArray()

let destFactory = InstanceFactory(case.ExpectedInstance.GetType(), [])
let instanceBuilder = InstanceBuilder(destFactory)
let binaryDirector = BinaryDirector()
use stream = new MemoryStream(data)
use reader = new BinaryReader(stream)
binaryDirector.Construct(reader, (factory :> IInstanceFactory).TargetSchema, instanceBuilder)

let copy = instanceBuilder.Instance
```

## Issues of Instance implementation

### Supported types for an array
Reading of an array will be successfull if corresponding type is:
* Dotnet array
* F# List
* Has constructor which accepts IEnumerable<_>

### Supported types for a map
Reading of a map will be successful if corresponding type is:
* F# Map<string,_>
* Dictionary<string,_>

## Issues of Json implementation

### byte array is encoded as base64 string

### decimal is encoded as number

# Forward Compatibility of Descriminated Unions

According to Avro standard, adding a new type at a union is a non forward compatible change ([see](https://avro.apache.org/docs/current/spec.html#Schema+Resolution)).

Let's pretend that first version of our domain is looks like:
```fsharp
type DomainUnion =
    | Case1
    | Case2

type DomainRecord = {
    Union : DomainUnion
}
```

Eventually, version 2 is evolved:
```fsharp
type DomainUnion =
    | Case1
    | Case2
    | Case3

type DomainRecord = {
    Union : DomainUnion
}
```

According to Avro standard, microservices that use old schema (version 1) should get an error trying deserialize a `DomainRecord` with `Case3`. This is big obstacle for evolution of algebraic types in domain modeling. Therefore the library substitutes unknown case with default value for a record field. For example, having following domain:

```fsharp
type UnionV1 =
    | UnknownCase
    | Case1

type RecordV1 = {
    [<DefaultValue """{"Foo.Bar.UnionV1.UnknownCase": {}}""">]
    Union : UnionV1
}

type UnionV2 =
    | UnknownCase
    | Case1
    | Case2
    | Case3

type RecordV2 = {
    Union : UnionV2
}
```

`{Union = Case3}:RecordV2` will be deserialized to `{Union = UnionV1.UnknownCase}:RecordV1` if `RecordV1` is target type.

Also unknown cases are skipped during reading encoded arrays and maps.

# Custom Rules

It is possible to customize processing of a particular type. In that case `CustomRule` should be created.
```fsharp
type CustomRule = {
    TargetType: System.Type;
    Schema: string
    SerializationCast: obj -> obj
    DeserializationCast: obj -> obj
}
```
There are several build in rules:
* `Guid` is mapped to byte array
* `Uri` is mapped to string
* `DateTime` is mapped to ISO 8601 string
* `DateTimeOffset` is mapped to ISO 8601 string
* `TimeSpan` is mapped to ISO 8601 string

Array with custom rules should be passed as first argument to `Schema.generate`.

# Examples
More examples of complex types and corresponging schemas is available in the [SchemaTests.fs](https://github.com/usix79/Avro.FSharp/blob/main/test/Avro.FSharp.Tests/SchemaTests.fs).

See [CustomRule.fs](https://github.com/usix79/Avro.FSharp/blob/main/src/Avro.FSharp/CustomRule.fs) for details of the implementation of the custom rules.

An implementation of Kafka producer and consumer, working with SchemaRegistry could be found [here](https://github.com/usix79/Avro.FSharp/tree/main/examples/KafkaSerde). (*The example is supposed you have an account in confluent.cloud. Change configuration code if you have on-premise installation.*)